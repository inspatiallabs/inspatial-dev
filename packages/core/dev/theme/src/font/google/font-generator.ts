// @ts-ignore: Allow importing .ts files in Deno
import type { GoogleFontProp as _GoogleFontProp } from "./prop.ts";

interface FontDefinition {
  name: string;
  weights: string[];
  styles: string[];
  subsets: string[];
  axes?: Array<{
    tag: string;
    min: number;
    max: number;
    defaultValue: number;
  }>;
}

export interface InSpatialFontProp {
  variable?: string;
  className: string;
  style:
    | string[]
    | {
        fontFamily: string;
        fontWeight?: number;
        fontStyle?: string;
      };
}

type Display = "auto" | "block" | "swap" | "fallback" | "optional";

function generateFontTypeUnion(fontMap: Record<string, any>): string {
  const fontNames = Object.keys(fontMap)
    .filter(key => fontMap[key] && fontMap[key].family) // Filter out entries without family property
    .map((key) => {
      // Convert snake_case to exact font family name from the map
      const fontFamily = fontMap[key].family;
      // Escape any special characters and wrap in quotes
      return `"${fontFamily.replace(/"/g, '\\"')}"`;
    });

  return `/**
   * All available Google Font families
   * Auto-generated from font-map.json
   */
  export type GoogleFontTypes =
    | ${fontNames.join("\n  | ")};\n`;
}

/**
 * Generates TypeScript declarations for Google Fonts
 */
export function generateGoogleFontTypes(
  fontMap: Record<string, any>,
  _outputPath: string
): string {
  let output = `// Auto-generated Google Font declarations
  // Generated on ${new Date().toISOString()}
  
  // @ts-ignore: Allow importing .ts files in Deno
  import type { InSpatialFontProp } from '../types.ts'
  // @ts-ignore: Allow importing .ts files in Deno
  import type { PrimitiveFontTypes } from '../primitive/types.ts'
  
  type Display = 'auto' | 'block' | 'swap' | 'fallback' | 'optional'
  
  ${generateFontTypeUnion(fontMap)}
  
  /**
   * Combined type of all available fonts (Google Fonts and Primitive Fonts)
   */
  export type AllFontVariants = GoogleFontTypes | PrimitiveFontTypes;
  
  `;

  // Rest of the existing generation code...
  output += `/**
   * ╔════════════════════════════════════════════════════════════════════════════╗
   * ║                    Google Fonts Type Declarations                          ║
   * ╠════════════════════════════════════════════════════════════════════════════╣
   * ║                                                                            ║
   * ║  Auto-generated type declarations for Google Fonts.                        ║
   * ║  DO NOT EDIT THIS FILE DIRECTLY - it is automatically generated.           ║
   * ║                                                                            ║
   * ║  To update this file, run the font generator script.                       ║
   * ║                                                                            ║
   * ╚════════════════════════════════════════════════════════════════════════════╝
   */\n\n`;

  for (const [key, font] of Object.entries(fontMap)) {
    try {
      if (!font) {
        console.warn(`Skipping undefined font for key: ${key}`);
        continue;
      }
      
      const fontName = formatFontNameForDeclaration(key);
      const fontDef = processFontDefinition(font);

      output += generateFontDeclaration(fontName, fontDef);
      output += "\n";
    } catch (err) {
      console.error(`Error processing font ${key}:`, err);
      // Continue with the next font rather than aborting the entire process
    }
  }

  // Return the generated content as a string
  return output;
}

/**
 * Formats a snake_case font name for TypeScript declaration
 */
function formatFontNameForDeclaration(key: string): string {
  return key
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("_");
}

/**
 * Processes raw font data into a structured definition
 */
function processFontDefinition(font: any): FontDefinition {
  if (!font) {
    // Return a default empty definition if font is undefined
    return {
      name: "Unknown",
      weights: [],
      styles: [],
      subsets: [],
      axes: undefined,
    };
  }

  // Safely extract properties, ensuring they are the right type
  const name = typeof font.family === 'string' ? font.family : "Unknown";
  const weights = Array.isArray(font.weights) ? font.weights : [];
  
  // Handle styles - convert to string array
  let styles: string[] = [];
  if (Array.isArray(font.style)) {
    styles = font.style.filter((style: any) => typeof style === 'string') as string[];
  } else if (typeof font.style === 'string') {
    styles = [font.style];
  }
  
  const subsets = Array.isArray(font.subsets) ? font.subsets : [];

  return {
    name,
    weights,
    styles,
    subsets,
    axes: font.axes,
  };
}

/**
 * Generates TypeScript declaration for a single font
 */
function generateFontDeclaration(name: string, font: FontDefinition): string {
  const weightsUnion = font.weights.map((w) => `'${w}'`).join(" | ");
  const stylesUnion = font.styles.map((s) => `'${s}'`).join(" | ");
  const subsetsUnion = font.subsets.map((s) => `'${s}'`).join(" | ");

  return `export declare function ${name}(
    options: {
      weight: ${weightsUnion} | Array<${weightsUnion}>
      style?: ${stylesUnion} | Array<${stylesUnion}>
      display?: Display
      variable?: string
      preload?: boolean
      fallback?: string[]
      adjustFontFallback?: boolean
      subsets?: Array<${subsetsUnion}>
      ${font.axes ? generateAxesOptions(font.axes) : ""}
    }
  ): InSpatialFontProp`;
}

/**
 * Generates TypeScript for font axes options
 */
function generateAxesOptions(axes: FontDefinition["axes"]): string {
  if (!axes) return "";

  return axes
    .map(
      (axis) => `
      ${axis.tag}?: number // min: ${axis.min}, max: ${axis.max}, default: ${axis.defaultValue}`
    )
    .join("");
}
